from Project_utils import *
import warnings

warnings.simplefilter("ignore")
np.random.seed(187)

alpha_opt = 0.234
D = 1
K = 4
N = 10000
p = [lambda loc: st.norm.rvs(loc=loc, scale=3)] * K
u0 = st.uniform(loc=-3, scale=6).rvs
Ns = 1
T_factor = 2
gammas = [1, 2, 4, 8, 16]
experiment_control_A_1 = [None] * len(gammas)
experiment_control_A_2 = [None] * len(gammas)
experiment_contrast_A = [None] * len(gammas)

# get data from disk or generate
val = input('Enter y to read data from disk, n to regenerate data\n')
for j, gamma in enumerate(gammas):
    file_full_name = 'data/ex4/full_gamma' + str(gamma) + '.obj'
    file_adaptive_name = 'data/ex4/adaptive_gamma' + str(gamma) + '.obj'
    file_simple_name = 'data/ex4/simple_gamma' + str(gamma) + '.obj'
    u = [lambda x, T=k: np.exp(-gamma * (x ** 2 - 1) ** 2 / (T_factor ** T)) for k in range(K)]
    u_adp = [lambda x, T=1: np.exp(-gamma * (x ** 2 - 1) ** 2 / T)] * K
    experiment_control_A_1[j] = ParallelTempering(D, K, N, p, u, u0, Ns)
    experiment_control_A_2[j] = ParallelTempering(D, K, N, p, u_adp, u0, Ns, alpha_opt)
    experiment_contrast_A[j] = ParallelTempering(D, K, N, p, u, u0, Ns)
    if val == 'n':
        # generate data from Markov Chain
        _, acc = experiment_control_A_1[j].generateMarkovChain(mode='full PT')
        print('Full PT: swapping acceptance rate when gamma=%d: %f' % (gamma, acc))
        _, acc = experiment_control_A_2[j].generateMarkovChain(mode='adaptive PT')
        print('Adaptive PT: swapping acceptance rate when gamma=%d: %f' % (gamma, acc))
        _, acc = experiment_contrast_A[j].generateMarkovChain(mode='simple PT')
        print('Simple PT: swapping acceptance rate when gamma=%d: %f' % (gamma, acc))
        experiment_control_A_1[j].save(file_full_name)
        experiment_control_A_2[j].save(file_adaptive_name)
        experiment_contrast_A[j].save(file_simple_name)
    else:
        # load data from disk
        experiment_control_A_1[j].load(file_full_name)
        experiment_control_A_2[j].load(file_adaptive_name)
        experiment_contrast_A[j].load(file_simple_name)

# plot the histograms of samples
fig = plt.figure(figsize=(30, 12))
for j, gamma in enumerate(gammas):
    ax = fig.add_subplot(3, 5, j + 1)
    experiment_control_A_1[j].plot_hist(ax, 'gamma = ' + str(gamma))
    ax = fig.add_subplot(3, 5, j + 5 + 1)
    experiment_control_A_2[j].plot_hist(ax, 'gamma = ' + str(gamma))
    ax = fig.add_subplot(3, 5, j + 10 + 1)
    experiment_contrast_A[j].plot_hist(ax, 'gamma = ' + str(gamma))
plt.savefig('figures/ex4/hist_1d.png')
plt.show()

# plot the auto-correlation plots
fig = plt.figure(figsize=(30, 12))
for j, gamma in enumerate(gammas):
    ax = fig.add_subplot(3, 5, j + 1)
    experiment_control_A_1[j].plot_acf(ax, 'gamma = ' + str(gamma))
    ax = fig.add_subplot(3, 5, 5 + j + 1)
    experiment_control_A_2[j].plot_acf(ax, 'gamma = ' + str(gamma))
    ax = fig.add_subplot(3, 5, 10 + j + 1)
    experiment_contrast_A[j].plot_acf(ax, 'gamma = ' + str(gamma))
plt.savefig('figures/ex4/acf_1d.png')
plt.show()

# plot the trace-plots
fig = plt.figure(figsize=(15, 30))
for j, gamma in enumerate(gammas):
    ax = fig.add_subplot(15, 1, j + 1)
    experiment_control_A_1[j].plot_trace(ax, 'gamma = ' + str(gamma))
    ax = fig.add_subplot(15, 1, 5 + j + 1)
    experiment_control_A_2[j].plot_trace(ax, 'gamma = ' + str(gamma))
    ax = fig.add_subplot(15, 1, 10 + j + 1)
    experiment_contrast_A[j].plot_trace(ax, 'gamma = ' + str(gamma))
plt.savefig('figures/ex4/trace_1d.png')
plt.show()

# compute the effective sample size
max_iter = 5
for j, gamma in enumerate(gammas):
    ess_full = experiment_control_A_1[j].get_effective_sample_size()
    ess_adap = experiment_control_A_2[j].get_effective_sample_size()
    ess_simple = experiment_contrast_A[j].get_effective_sample_size()
    for l in range(max_iter - 1):
        experiment_control_A_1[j].generateMarkovChain('full PT')
        experiment_control_A_2[j].generateMarkovChain('adaptive PT')
        experiment_contrast_A[j].generateMarkovChain('simple PT')
        ess_full += experiment_control_A_1[j].get_effective_sample_size()
        ess_adap += experiment_control_A_2[j].get_effective_sample_size()
        ess_simple += experiment_contrast_A[j].get_effective_sample_size()
    print('average of ' + str(max_iter) + ' times of running')
    print('effective sample size with gamma = %d generated by full PT: %f' % (gamma, ess_full / max_iter))
    print('effective sample size with gamma = %d generated by adaptive PT: %f' % (gamma, ess_adap / max_iter))
    print('effective sample size with gamma = %d generated by simple PT: %f' % (gamma, ess_simple / max_iter))

alpha_opt = 0.234
D = 2
K = 4
N = 10000
p = [lambda loc: st.multivariate_normal.rvs(mean=loc, cov=np.array([[1, 0], [0, 0.5]]))] * K
u0 = st.uniform(loc=np.array([-2, -1]), scale=np.array([15, 4])).rvs
Ns = 1
T_factor = 2
u = [lambda x, T=k: np.exp(post(x) / T_factor ** T) for k in range(K)]
u_adp = [lambda x, T=1: np.exp(post(x) / T)] * K
experiment_control_B_1 = ParallelTempering(D, K, N, p, u, u0, Ns)
experiment_control_B_2 = ParallelTempering(D, K, N, p, u, u0, Ns, alpha_opt)
experiment_contrast_B = ParallelTempering(D, K, N, p, u, u0, Ns)
file_full_2d_name = 'data/ex4/full_csqi.obj'
file_adaptive_2d_name = 'data/ex4/adpative_csqi.obj'
file_simple_2d_name = 'data/ex4/simple_csqi.obj'

# get data from disk or generate
val = input('Enter y to read data from disk, n to regenerate data\n')
if val == 'n':
    # generate data from Markov Chain
    _, acc = experiment_control_B_1.generateMarkovChain(mode='full PT')
    print('Full PT: swapping acceptance rate in multi-modal distribution: %f' % (acc))
    _, acc = experiment_control_B_2.generateMarkovChain(mode='adaptive PT')
    print('Adaptive PT: swapping acceptance rate in multi-modal distribution: %f' % (acc))
    _, acc = experiment_contrast_B.generateMarkovChain(mode='simple PT')
    print('simple PT: swapping acceptance rate in multi-modal distribution: %f' % (acc))
    experiment_control_B_1.save(file_full_2d_name)
    experiment_control_B_2.save(file_adaptive_2d_name)
    experiment_contrast_B.save(file_simple_2d_name)
else:
    # load from disk
    experiment_control_B_1.load(file_full_2d_name)
    experiment_control_B_2.load(file_adaptive_2d_name)
    experiment_contrast_B.load(file_simple_2d_name)

# plot the histograms of samples
fig = plt.figure(figsize=(20, 7))
ax = fig.add_subplot(3, 1, 1)
experiment_control_B_1.plot_hist2d(ax, "multi-modal distribution")
ax = fig.add_subplot(3, 1, 2)
experiment_control_B_2.plot_hist2d(ax, "multi-modal distribution")
ax = fig.add_subplot(3, 1, 3)
experiment_contrast_B.plot_hist2d(ax, "multi-modal distribution")
plt.savefig('figures/ex4/csqi_hist2d.png')
plt.show()

# plot the auto-correlation plots
fig = plt.figure(figsize=(20, 7))
ax1, ax2 = fig.add_subplot(2, 3, 1), fig.add_subplot(2, 3, 4)
experiment_control_B_1.plot_acf2d([ax1, ax2], 'multi-modal distribution', k=100)
ax1, ax2 = fig.add_subplot(2, 3, 2), fig.add_subplot(2, 3, 5)
experiment_control_B_2.plot_acf2d([ax1, ax2], 'multi-modal distribution', k=100)
ax1, ax2= fig.add_subplot(2, 3, 3), fig.add_subplot(2, 3, 6)
experiment_contrast_B.plot_acf2d([ax1, ax2], 'multi-modal distribution', k=100)
plt.savefig('figures/ex4/csqi_acf2d.png')
plt.show()

# plot the trace-plots
fig = plt.figure(figsize=(20, 7))
ax = fig.add_subplot(3, 1, 1)
experiment_control_B_1.plot_trace2d(ax, 'multi-modal distribution')
ax = fig.add_subplot(3, 1, 2)
experiment_control_B_2.plot_trace2d(ax, 'multi-modal distribution')
ax = fig.add_subplot(3, 1, 3)
experiment_contrast_B.plot_trace2d(ax, 'multi-modal distribution')
plt.savefig('figures/ex4/csqi_trace2d.png')
plt.show()

# compute the efficient sample size
max_iter = 1
ess_full = experiment_control_B_1.get_effective_sample_size_2d()
ess_adap = experiment_control_B_2.get_effective_sample_size_2d()
ess_simple = experiment_contrast_B.get_effective_sample_size_2d()
for l in range(max_iter-1):
    experiment_control_B_1.generateMarkovChain(mode='full PT')
    experiment_control_B_2.generateMarkovChain(mode='adaptive PT')
    experiment_contrast_B.generateMarkovChain(mode='simple PT')
    ess_full += experiment_control_B_1.get_effective_sample_size_2d()
    ess_adap += experiment_control_B_2.get_effective_sample_size_2d()
    ess_simple += experiment_contrast_B.get_effective_sample_size_2d()
print('average of ' + str(max_iter) + ' times of running')
print('effective sample size of (theta1, theta2) for Markov chain generated by full PT: (%f, %f)' % (ess_full[0] / max_iter, ess_full[1] / max_iter))
print('effective sample size of (theta1, theta2) for Markov chain generated by adaptive PT: (%f, %f)' % (ess_adap[0] / max_iter, ess_adap[1] / max_iter))
print('effective sample size of (theta1, theta2) for Markov chain generated by simple PT: (%f, %f)' % (ess_simple[0] / max_iter, ess_simple[1] / max_iter))


'''
1d distribution
average of 5times of running
effective sample size with gamma = 1 generated by full PT: 7943.426312
effective sample size with gamma = 1 generated by adaptive PT: 2968.091286
effective sample size with gamma = 1 generated by simple PT: 3790.643926
average of 5times of running
effective sample size with gamma = 2 generated by full PT: 3253.115917
effective sample size with gamma = 2 generated by adaptive PT: 3605.933870
effective sample size with gamma = 2 generated by simple PT: 3773.710266
average of 5times of running
effective sample size with gamma = 4 generated by full PT: 3466.632831
effective sample size with gamma = 4 generated by adaptive PT: 1885.750283
effective sample size with gamma = 4 generated by simple PT: 2268.379143
average of 5times of running
effective sample size with gamma = 8 generated by full PT: 2982.661723
effective sample size with gamma = 8 generated by adaptive PT: 1384.421461
effective sample size with gamma = 8 generated by simple PT: 1474.533959
average of 5times of running
effective sample size with gamma = 16 generated by full PT: 1207.474333
effective sample size with gamma = 16 generated by adaptive PT: 4200.688337
effective sample size with gamma = 16 generated by simple PT: 19627.768833
'''